---
title: '<span style="font-size:48pt;">Support Vector Machines</span>'
subtitle: 'üöß  üõ£Ô∏è  ü¶ø ' 
author: 'Applied Machine Learning in R <br />Pittsburgh Summer Methodology Series'
date: 'Lecture 4-A &emsp; &emsp; July 22, 2021'
output:
  xaringan::moon_reader:
    css: xaringan-themer.css
    nature:
      beforeInit: "macros.js"
      slideNumberFormat: "%current% / %total%"
      highlightStyle: github
      highlightLines: true
      ratio: 16:9
      countIncrementalSlides: false
    self_contained: true
---

```{r setup, include=FALSE}
options(htmltools.dir.version = FALSE)
knitr::opts_chunk$set(
  fig.width=9, fig.height=3.5, fig.retina=3,
  fig.showtext = TRUE,
  out.width = "100%",
  cache = FALSE,
  echo = TRUE,
  message = FALSE, 
  warning = FALSE,
  hiline = TRUE,
  comment = "#>",
  collapse = TRUE
)
```

```{r xaringan-themer, include=FALSE, warning=FALSE}
library(xaringanthemer)
style_mono_light(
  base_color = "#23395b",
  footnote_font_size = "20px",
  footnote_color = "gray",
  text_slide_number_font_size = "18px"
)
```

```{r xaringan-tachyons, echo=FALSE}
xaringanExtra::use_tachyons()
xaringanExtra::use_clipboard()
```

```{r packages, echo=FALSE, message=FALSE}
library(tidyverse)
library(knitr)
library(kableExtra)
library(countdown)
library(patchwork)
library(caret)
library(recipes)
```

class: inverse, center, middle
# Overview

<style type="text/css">
.onecol {
    font-size: 26px;
}
.twocol {
  font-size: 24px;
}
.remark-code {
  font-size: 24px;
  border: 1px solid grey;
}
a {
  background-color: lightblue;
}
.remark-inline-code {
  background-color: white;
}
</style>

---
class: onecol
## Roadmap

1. Maximal Margin Classifier üö∂

1. Support Vector Classifier üèÉ

1. Support Vector Machine üö¥

1. Applied Example

1. Support Vector Regression

1. Live Coding

1. Hands-on Activity

---
class: onecol
## Notices and Disclaimers

The ideas underlying SVM are really *clever* and *interesting*! üòÉ

--

SVM is also a good algorithm for *smaller*, *messy* datasets!! üòç

--

However, there is a lot of *terminology* and *math* involved... üò±

--

<p style="padding-top:15px;">I will try to shield you from this and give only <b>the necessities</b></p>

- That means there will be some things I need to "hand waive"

- I may also need to skip questions that may confuse others

--

<p style="padding-top:15px;">But you should get a <b>strong intuition</b> and <b>applied knowledge</b></p>

- You could then dive into a longer course or textbook

---
class: inverse, center, middle
# SVM Intuitions
---
class: onecol
## Maximal Margin Classifier

How do we predict the class of a new data point?

```{r, echo=FALSE, out.width='100%'}
include_graphics("maxmargin1.png")
```

---
class: onecol
## Maximal Margin Classifier

With one feature, we need to find a point that separates the classes

```{r, echo=FALSE, out.width='100%'}
include_graphics("maxmargin2.png")
```

---
class: onecol
## Maximal Margin Classifier
But there are many possible decision points, so which should we use?

```{r, echo=FALSE, out.width='100%'}
include_graphics("maxmargin3.png")
```

---
class: onecol
## Maximal Margin Classifier
One option is to find the point with the **maximal margin** between the classes

```{r, echo=FALSE, out.width='100%'}
include_graphics("maxmargin4.png")
```

---
class: onecol
## Maximal Margin Classifier

With two features, we need a 2D plot and a decision **line**

```{r, echo=FALSE, out.width='80%'}
include_graphics("maxmargin5.png")
```

---
class: onecol
## Maximal Margin Classifier

With three features, we need a 3D plot and a decision **plane**

```{r, echo=FALSE, out.width='50%'}
include_graphics("3d_plane.gif")
```

---
class: onecol
## Maximal Margin Classifier

With four or more features, we can't plot it but we need a decision **hyperplane**

--

.bg-light-yellow.b--light-red.ba.bw1.br3.pl4[
**Caution:** You may hurt yourself if you try to imagine what a hyperplane looks like.
]

--

.pt1[
**Margins still exist** in higher-dimensional space and we still want to maximize them
]

- Our goal is thus to locate the class-separating hyperplane with the largest margin

- The math behind this is beyond the scope of our workshop, but that's the idea

--

The hyperplane allows us to **classify new observations** (which side of it do they fall on?)

- Since the dimensions of this space are determined by the features, we are exploring "feature space" and looking for regions occupied by each class

---
class: onecol
## Maximal Margin Classifier

Only the observations that define the margin, called ![:emphasize](support vectors), are used

Thus, it (and related methods) focus on the most ambiguous/difficult examples

```{r, echo=FALSE, out.width='80%'}
include_graphics("maxmargin8.png")
```

---
class: onecol
## Maximal Margin Classifier

This means that **outliers can have an outsized impact** on what is learned

For instance, this margin is likely to misclassify examples in new data

```{r, echo=FALSE, out.width='80%'}
include_graphics("maxmargin9.png")
```

---
class: onecol
## Support Vector Classifier

The ![:emphasize](Support Vector Classifier) (SVC) innovates by allowing the outlier to be misclassified

This will **increase bias** (training errors) but hopefully **decrease variance** (testing errors)

```{r, echo=FALSE, out.width='80%'}
include_graphics("svc1.png")
```

---
class: onecol
## Support Vector Classifier

SVCs also work better than MMCs when the classes are **not perfectly separable**

An MMC's hyperplane is never going to separate these classes without errors

```{r, echo=FALSE, out.width='80%'}
include_graphics("svc2.png")
```

---
class: onecol
## Support Vector Classifier

But if we allow a few errors and points within the margin...

...we may be able to find a hyperplane that generalizes pretty well

```{r, echo=FALSE, out.width='80%'}
include_graphics("svc3.png")
```

---
class: onecol
## Support Vector Classifier

When points are on the wrong side of the margin, they are called "violations"

A **soft margin** allows violations, whereas a **hard margin** does not (as in MMC)

SVCs have a hyperparameter $C$ that controls margin "softness" on a continuum

--

<p style="padding-top:10px;">This hyperparameter controls the number and magnitude of violations allowed</p>

- A **lower $C$ value** makes the margin harder (allows fewer violations)
  
  As a result, the model has **lower bias** but is more likely to overfit for higher variance

- A **higher $C$ value** makes the margin softer (allows more violations)

  As a result, the model has more bias but is less likely to overfit for **lower variance**

---
class: onecol
## Support Vector Machine

So far, MMC and SVCs have both used linear (e.g., flat) hyperplanes

But there are many times when the classes are not **linearly separable**

```{r, echo=FALSE, out.width='80%'}
include_graphics("svm1.png")
```

.footnote[[1] Good luck separating these classes with a single decision point...]

---
class: onecol
## Support Vector Machine

But if we enlarge the feature space, the classes might then become linearly separable

There are many ways to do this enlarging, but one is to add polynomial expansions

```{r, echo=FALSE, out.width='80%'}
include_graphics("svm2.png")
```

---
class: onecol
## Support Vector Machine

The classes are now linearly separable in this new enlarged feature space!

```{r, echo=FALSE, out.width='80%'}
include_graphics("svm3.png")
```

---
class: onecol
## Support Vector Machine
The ![:emphasize](Support Vector Machine) (SVM) allows us to efficiently enlarge the feature space

- Part of what makes SVMs efficient is they **only consider the support vectors**

- They also use **kernel functions** to quantify the similarity of pairs of support vectors<sup>1</sup>

<p style="padding-top:15px;">The SVC can actually be considered a simple version of the SVM with a <b>linear kernel</b></p>

- A linear kernel essentially quantifies similarity using the Pearson correlation

$$K(x_i, x_{i'}) = \sum_{j=1}^p x_{ij}x_{i'j}$$

.footnote[[1] These similarity estimates are used to efficiently find the optimal hyperplane but that process is complex.]

---
class: onecol
## Support Vector Machine

It is common to also use **nonlinear** kernels, such as the ![:emphasize](polynomial kernel)

$$K(x_i, x_{i'}) = (1 + \sum_{j=1}^p x_{ij} x_{i'j})^d$$

With larger values of $d$, the decision boundary can become more flexible/complex

- You are essentially adding polynomial expansions of degree $d$ to each predictor

- You have expanded the feature space and may now have linear separation

- This is the same idea we just used in fitting a hyperplane in the $x\text{-by-}x^2$ space!

.footnote[[1] When `\\(d=1\\)`, the polynomial kernel reduces to the linear kernel and SVM becomes SVC again.]

---
class: onecol
## Support Vector Machine

Perhaps the most common kernel is the ![:emphasize](radial basis function) (RBF) or radial kernel

$$K(x_i,x_{i'})=\exp\left(-\gamma\sum_{j=1}^p(x_{ij}-x_{i'j})^2\right)$$

--

The intuition here is that similarity is weighted by how close the observations are

- Only support vectors near new observations influence classification strongly

The RBF kernel actually computes similarity between points in *infinite* dimensions<sup>1</sup>

As the $\gamma$ hyperparameter increases, the more nonlinear and complex fit becomes

.footnote[[1] This is part of why RBF is so popular: who needs more than infinite dimensions?!]

---
## Support vector regression

---
## Applied Example

---
## Live Coding Activity

---
## Hands-on Activity

---
## Break and timer
