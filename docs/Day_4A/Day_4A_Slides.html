<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Support Vector Machines</title>
    <meta charset="utf-8" />
    <meta name="author" content="Applied Machine Learning in R  Pittsburgh Summer Methodology Series" />
    <script src="Day_4A_Slides_files/header-attrs/header-attrs.js"></script>
    <link href="Day_4A_Slides_files/tachyons/tachyons.min.css" rel="stylesheet" />
    <script src="Day_4A_Slides_files/clipboard/clipboard.min.js"></script>
    <link href="Day_4A_Slides_files/xaringanExtra-clipboard/xaringanExtra-clipboard.css" rel="stylesheet" />
    <script src="Day_4A_Slides_files/xaringanExtra-clipboard/xaringanExtra-clipboard.js"></script>
    <script>window.xaringanExtraClipboard(null, {"button":"Copy Code","success":"Copied!","error":"Press Ctrl+C to Copy"})</script>
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# <span style="font-size:48pt;">Support Vector Machines</span>
## üöß üõ£Ô∏è ü¶ø
### Applied Machine Learning in R <br />Pittsburgh Summer Methodology Series
### Lecture 4-A ‚ÄÉ ‚ÄÉ July 22, 2021

---










class: inverse, center, middle
# Overview

&lt;style type="text/css"&gt;
.onecol {
    font-size: 26px;
}
.twocol {
  font-size: 24px;
}
.remark-code {
  font-size: 24px;
  border: 1px solid grey;
}
a {
  background-color: lightblue;
}
.remark-inline-code {
  background-color: white;
}
&lt;/style&gt;

---
class: onecol
## Roadmap

.left-column[
.pt4[
&lt;img src="../figs/map.jpg" width="100%" /&gt;
]
]

.right-column[
1. Maximal Margin Classifier üö∂

1. Support Vector Classifier üèÉ

1. Support Vector Machine üö¥

1. Support Vector Regression üöµ

1. Applied Example

1. Live Coding

1. Hands-on Activity
]


---
class: onecol
## Notices and Disclaimers

The ideas underlying SVM are really *clever* and *interesting*! üòÉ

--

SVM is also a good algorithm for *smaller*, *messy* datasets!! üòç

--

However, there is a lot of *terminology* and *math* involved... üò±

--

&lt;p style="padding-top:15px;"&gt;I will try to shield you from this and give only &lt;b&gt;the necessities&lt;/b&gt;&lt;/p&gt;

- That means there will be some things I need to "hand waive"

- I may also need to skip questions with very technical answers

--

&lt;p style="padding-top:15px;"&gt;But you should get a &lt;b&gt;strong intuition&lt;/b&gt; and &lt;b&gt;applied knowledge&lt;/b&gt;&lt;/p&gt;

- This will prepare you nicely to dive into a longer course on the topic

---
class: inverse, center, middle
# SVM Intuitions
---
class: onecol
## A Tale of Two Classes

If this is our training data, how do we **predict the class** of new data?

&lt;img src="../figs/maxmargin1.png" width="100%" /&gt;

---
class: onecol
## Drawing a Line in the Sand

With one feature, we could find a **point** that separates the classes (as higher or lower)

&lt;img src="../figs/maxmargin2.png" width="100%" /&gt;

---
class: onecol
## Analysis Paralysis
But there are many possible decision points, so **which should we use?**

&lt;img src="../figs/maxmargin3.png" width="100%" /&gt;

---
class: onecol
## Maximal Margin Classifier (MMC)
The MMC algorithm finds and uses the point with the **largest** (i.e., maximal) ![:emphasize](margin)

&lt;img src="../figs/maxmargin4.png" width="100%" /&gt;

---
class: onecol
## Maximal Margin Classifier

If we have two features, we can extend this idea using a 2D plot and a decision **line**

&lt;img src="../figs/maxmargin5.png" width="80%" /&gt;

---
class: onecol
## Maximal Margin Classifier

If we have three features, we will need a 3D plot and a decision **plane** (i.e., flat surface)

&lt;img src="../figs/3d_plane.gif" width="45%" /&gt;

.footnote[[1] Credit to [Zahra Elhamraoui](https://medium.datadriveninvestor.com/support-vector-machine-svm-algorithm-in-a-fun-easy-way-fc23a008c22) for this visualization.]

---
class: onecol
## Maximal Margin Classifier

If we have four or more features, we will need a decision **hyperplane**

--

.bg-light-yellow.b--light-red.ba.bw1.br3.pl4[
**Caution:** You may hurt yourself if you try to imagine what a hyperplane looks like. 
.tr.pr4[
But here is a hint: üç´‚úàÔ∏è
]
]

--

.pt1[
**Margins still exist** in higher-dimensional space and we still want to maximize them
]

- Our goal is thus to locate the class-separating hyperplane with the largest margin

- The math behind this is beyond the scope of our workshop, but that's the idea

--

.pt1[
We can still **classify new observations**: which side of the hyperplane do they fall on?
]

---
class: onecol
## Maximal Margin Classifier

Only the observations that define the margin, called ![:emphasize](support vectors), are used

Because it only uses a subset of data anyway, MMC does well with smaller datasets

&lt;img src="../figs/maxmargin8.png" width="80%" /&gt;

---
class: onecol
## Maximal Margin Classifier

This means that **outliers can have an outsized impact** on what is learned

For instance, this margin is likely to misclassify examples in new data

&lt;img src="../figs/maxmargin9.png" width="80%" /&gt;

---
class: onecol
## Support Vector Classifier (SVC)

The SVC algorithm is like MMC but it **allows examples to be misclassified** (i.e., wrong)

This will **increase bias** (training errors) but hopefully **decrease variance** (testing errors)

&lt;img src="../figs/svc1.png" width="80%" /&gt;

---
class: onecol
## Support Vector Classifier

SVCs also enable a model to be trained when the classes are **not perfectly separable**

A straight line is never going to separate these classes without errors (sorry MMC...)

&lt;img src="../figs/svc2.png" width="80%" /&gt;

---
class: onecol
## Support Vector Classifier

But if we allow a few errors and points within the margin...

...we may be able to find a hyperplane that generalizes pretty well

&lt;img src="../figs/svc3.png" width="80%" /&gt;

---
class: onecol
## Support Vector Classifier

When points are on the wrong side of the margin, they are called "violations"

A **softer margin** allows more violations, whereas a **harder margin** allows fewer

SVCs have a hyperparameter `\(C\)` that controls how soft vs. hard the margin is

--

- A **lower `\(C\)` value** makes the margin harder (allows fewer violations)&lt;sup&gt;1&lt;/sup&gt;
  
  As a result, the model has **lower bias** and more flexibility but may overfit

- A **higher `\(C\)` value** makes the margin softer (allows more violations)

  As a result, the model has less flexibility but may also have **lower variance**

.footnote[
[1] If you set `\(C=0\)` (i.e., a fully hard margin) SVC will allow no violations  and behave the same as MMC.]

---
class: onecol
## Support Vector Machine

So far, MMC and SVCs have both used linear (e.g., flat) hyperplanes

But there are many times when the classes are not **linearly separable**

&lt;img src="../figs/svm1.png" width="80%" /&gt;

.footnote[[1] These classes seem separable, but not with a single decision point...]

---
class: onecol
## Support Vector Machine

But if we enlarge the feature space, the classes might then become linearly separable

There are many ways to do this enlarging, but one is to add polynomial expansions

&lt;img src="../figs/svm2.png" width="80%" /&gt;

---
class: onecol
## Support Vector Machine

The classes are now linearly separable in this new enlarged feature space!

The hyperplane is flat in this new space, but would not look so in the original space

&lt;img src="../figs/svm3.png" width="80%" /&gt;

---
class: onecol
## Support Vector Machine

Here is a more complex example of a nonlinear (and non-polynomial) expansion

&lt;img src="../figs/svm4.png" width="75%" /&gt;

.footnote[[1] Credit to [Erik Kim](https://www.eric-kim.net/eric-kim-net/posts/1/kernel_trick.html) for this example and visualization.]

---
class: onecol
## Support Vector Machine

And here is the hyperplane: it is linear in 3D but not when "projected" back into 2D

&lt;img src="../figs/svm5.png" width="75%" /&gt;

.footnote[[1] Credit to [Erik Kim](https://www.eric-kim.net/eric-kim-net/posts/1/kernel_trick.html) for this example and visualization.]

---
class: onecol
## Support Vector Machine
The ![:emphasize](Support Vector Machine) (SVM) allows us to efficiently enlarge the feature space

- Part of what makes SVMs efficient is they **only consider the support vectors**

- They also use **kernel functions** to quantify the similarity of pairs of support vectors&lt;sup&gt;1&lt;/sup&gt;

.footnote[[1] These similarity estimates are used to efficiently find the optimal hyperplane but that process is complex.]

--

&lt;p style="padding-top:15px;"&gt;The SVC can actually be considered a simple version of the SVM with a &lt;b&gt;linear kernel&lt;/b&gt;&lt;/p&gt;

- A linear kernel essentially quantifies similarity using the Pearson correlation

`$$k(x, x') = \langle x, x'\rangle$$`

--

&lt;p style="padding-top:15px;"&gt;Linear kernels are efficient but &lt;b&gt;nonlinear kernels&lt;/b&gt; may provide better performance&lt;/b&gt;&lt;/p&gt;


---
exclude: true
class: onecol
## Support Vector Machine

It is common to also use **nonlinear** kernels, such as the ![:emphasize](polynomial kernel)

`$$k(x, x')=(\text{scale} \cdot \langle x, x' \rangle + \text{offset})^\text{degree}$$`

With larger values of `\(\text{degree}\)`, the decision boundary can become more complex

- You are essentially adding polynomial expansions of `\(\text{degree}\)` to each predictor

- You have expanded the feature space and may now have linear separation

- This is the same idea we just used in fitting a hyperplane in the `\(x\text{-by-}x^2\)` space!

If you center or normalize all your predictors, you can drop the `\(\text{offset}\)` term

.footnote[[1] When `\\(\text{degree}=1\\)`, the polynomial kernel reduces to the linear kernel and SVM becomes SVC again.]

---
class: onecol
## Support Vector Machine

Perhaps the most common nonlinear kernel is the ![:emphasize](radial basis function) (RBF)

`$$k(x, x') = \exp\left(-\sigma \|x-y\|^2\right)$$`

--

The intuition here is that similarity is weighted by how *close* the observations are

- Only support vectors near new observations influence classification strongly

- As the `\(\sigma\)` hyperparameter&lt;sup&gt;1&lt;/sup&gt; increases, the more *local* and complex fit becomes

--

The RBF kernel computes similarity between points in *infinite* dimensions ü§Ø

- It is considered an ideal "general purpose" nonlinear kernel&lt;sup&gt;2&lt;/sup&gt; 

--

.footnote[
[1] Note that `\(\sigma\)` is also sometimes called `\(\gamma\)` or the "scale" hyperparameter.&lt;br /&gt;
[2] Other nonlinear kernels are popular for special purposes and in specialized subfields.
]

---
class: onecol
## Support Vector Regression Machine (SVR)

So far we have been concerned only with classification, but what about regression?

In another very clever turn, you can **adapt SVM for regression** by reversing its goal

- Instead of trying to separate classes and keep data points outside of the margin...

- ...SVR instead tries to **keep all the data points** ![:emphasize](inside the margin) (with no classes)

---
class: onecol
## Support Vector Regression Machine


All the benefits of the SVM algorithm can be applied to the regression problem

- Using a subset of the data points to define the margin, i.e., **support vectors**

- Allowing violations (now points *outside* the margin) with a **soft margin**

- Efficiently expanding the feature space through the use of **various kernels**

We can use the same {caret} `method` and hyperparameters for SVM and SVR

- We will use `\(C\)` to control the softness vs. hardness of the margin

- If we use an RBF kernel, we will use `\(\sigma\)` to control the kernel scaling

---
## Applied Example




---
## Live Coding Activity

---
## Hands-on Activity

---
## Break and timer
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="macros.js"></script>
<script>var slideshow = remark.create({
"slideNumberFormat": "%current% / %total%",
"highlightStyle": "github",
"highlightLines": true,
"ratio": "16:9",
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
